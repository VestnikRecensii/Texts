\documentclass{article}

\input{common}
\begin{document}
\input{fontsize}

\chaptertitle{Введение}

\maketitle %uncomment for title

\section*{Предисловие}

Недавно ко мне обратился один человек с просьбой сделать ему простую программу --- берутся одни данные и по простейшей формуле из них строятся другие. Тот человек думал, что раз \glqqяжпрограммист\grqq, то для меня решение его задачи не составит труда. Я и вправду справился, но грустная правда заключалась в том, что для решения вполне хватило стандартных формул Excel и пары-тройки минут свободного времени.

Программированию может научиться любой. Для этого не нужно ни специальное образование, ни платные двухнедельные курсы, ни особый склад ума. Но, к сожалению, до сих пор часто считается, что программирование сродни магии, которую хорошо бы отдать на откуп волшебникам-программистам, а самим об этом забыть. Но только это так не работает. 

Автоматизировать можно почти все --- от офисной работы до квестов. Знание всего лишь основ программирования выделяет человека на рынке труда и сильно упрощает ему жизнь на работе (главное, не соглашайтесь чинить чайники). Умение программировать позволяет взглянуть на повседневные задачи под несколько иным углом. Программирование полезно для всех, даром, и пусть никто не уйдет обиженным.

Этот материал как раз и предназначен для того, чтобы программирование стало ближе для каждого. Чтобы сделать его еще более простым, я максимально снизил порог вхождения, из-за чего придется объяснять вещи, кажущиеся некоторым очевидными. Они оформлены вот таким образом:

\fordummies{Полковник Фридрих Краус фон Циллергут (Циллергут --- название деревушки в Зальцбурге, которую предки полковника пропили еще в восемнадцатом столетии) был редкостный болван. Рассказывая о самых обыденных вещах, он всегда спрашивал, все ли его хорошо поняли, хотя дело шло о примитивнейших понятиях, например: <<Вот это, господа, окно. Да вы знаете, что такое окно?>> Или: <<Дорога, по обеим сторонам которой тянутся канавы, называется шоссе. Да-с, господа. Знаете ли вы, что такое канава? Канава — это выкопанное значительным числом рабочих углубление. Да-с. Копают канавы при помощи кирок. Известно ли вам, что такое кирка?>> Он страдал манией все объяснять и делал это с воодушевлением, с каким изобретатель рассказывает о своем изобретении. <<Книга, господа, это множество нарезанных в четвертку листов бумаги разного формата, напечатанных и собранных вместе, переплетенных и склеенных клейстером. Да-с. Знаете ли вы, господа, что такое клейстер? Клейстер — это клей>>. 

\begin{flushright}Ярослав Гашек, <<Похождения бравого солдата Швейка>>\end{flushright}}

Если то, что там написано, кажется вам очевидным или слишком упрощенным, смело пропускайте, эта часть материала предназначена для менее посвященных.

Слова и небольшие фрагменты исходного кода, находящиеся внутри текста оформлены так - \cppword{int main() \{\}}, а полноценные примеры --- так:

\begin{lstlisting}[caption={Пример оформления кода}, captionpos=b, style=cpp]
#include <iostream>
using namespace std;

int main() {
	cout << "Hello, World!" << endl;
	return 0;
}
\end{lstlisting}

Как вы уже догадались, мы будем изучать программирование на примере C++. Почему не Ruby, Python, Go или что-то другое стильное модное молодежное? И порог вхождения в плюсы довольно высок, и синтаксис далек от совершенства, казалось бы, C++ явно не является языком, с которого надо начинать изучение программирования. Однако, с этим можно поспорить. Си-подобный синтаксис используется ныне в Java, JavaScript, C\#, Objective C и многих других. Некоторая сложность синтаксиса компенсируется широтой его применения. Выучил синтаксис однажды --- используешь постоянно.

C++ за десятилетия своего развития объединил под своим крылом самые разные концепции и возможности --- здесь можно вручную управлять памятью, а можно положиться на автоматические контейнеры, можно использовать средства из восьмидесятых годов в разработке современного мобильного приложения, можно писать максимально быстрый и близкий к низкому уровню код и в то же время защищать пользователя с помощью исключений.

C++ ныне имеет уже солидный возраст, но все еще успешно борется с более молодыми --- на нем пишут компиляторы и другие языки, браузеры, игры, среды разработки, мобильные и десктопные приложения и многое другое. Хотите быть с теми, кто этим занимается? Вливайтесь.

\section*{История вопроса}

Давным-давно компьютеры были большими, а программы маленькими. Они представляли собой машинные команды в виде строк нулей и единиц (многие люди еще с тех пор считают смешными шутки про двоичный код и программистов). Несколько позже был создан ассемблер, где каждая команда представляет собой слово или сокращение на английском языке. А с появлением языков высокого уровня жизнь программистов стала почти сказочной --- теперь для написания программы использовался какой-никакой язык с конструкциями из слов и предложений. Можно было написать что-то вроде <<Пусть а равно 1>> и компилятор или интерпретатор преобразовывал эту запись в понятный машине код.

\fordummies{

Компилятор --- программа, переводящая текст с языка высокого уровня на язык низкого уровня, близкий машинному коду. Например, на входе мы имеем текст программы на C++, а на выходе --- исполняемый exe-файл.

Интерпретатор же поступает иначе - пользователь скармливает ему текст программы, а тот построчно его анализирует и выполняет. Например, так работает Python, Ruby или JavaScript под капотом веб-страницы.

Т.о. программа на компилируемом языке представляет собой две сущности --- исходный код до компиляции и двоичный файл после, а у интерпретируемых языков никакой разницы нет, там исходный код является одновременно и текстом программы и самим исполняемым файлом. Программа на интерпретируемом языке сможет работать на любой машине, где есть соответствующий интерпретатор, однако без интерпретатора она бесполезна. А скомпилированная программа будет работать только на соответствующей операционной системе и архитектуре, но для ее запуска дополнительно программное обеспечение вроде компилятора уже не нужно (хотя могут быть нужны различные библиотеки, но пока не стоит вдаваться в такие подробности).

}

Программисты продолжали совершенствовать свои рабочие инструменты и создавали новые, и в начале 1980-х годов свет увидело детище Бьёрна Страуструпа --- язык, первоначально названный Си с классами. 

Работая в компании Bell Labs, Страуструп сталкивался с задачами, решать которые уже существующими средствами было неудобно --- одни языки были выразительны, высокоуровневы и удобны, но им не хватало скорости, другие слишком походили на ассемблер, а разрабатывать на нем большие программные продукты --- сомнительное удовольствие. Бьёрн Страуструп (тогда ему было около тридцати) вспомнил молодость и свою диссертацию и дополнил язык Си высокоуровневыми возможностями, добавив классы, наследование, строгую проверку типов, inline-функции и аргументы по умолчанию (не переживайте, если часть этих слов вам незнакома, со временем мы до них доберемся).

Страуструп написал транслятор, переводящий исходный код C с классами в исходный код чистого C. Благодаря такой совместимости новый язык быстро набрал популярность , но вскоре он перестал быть просто дополнением С и был переименован в C++. В 1985 году состоялся первый коммерческий выпуск, а вот первый международный стандарт языка появился спустя аж 13 лет --- в 1998 году. Следующие версии стандарта вышли в свет в 2003, 2011 и 2014 годах.

За годы своего развития C++ получил множество новых возможностей, потерял совместимость с C, а также приобрел множество яростных сторонников и противников. Бьёрн Страуструп как-то сказал: <<Есть всего два типа языков программирования: те, на которые люди всё время ругаются, и те, которые никто не использует>>. Судя по всему, C++ еще долго будет принадлежать к первому типу.

\section*{Собственно, C++}

Для работы нам понадобятся компилятор с текстовым редактором или среда разработки. Сейчас их огромное множество и каждый может выбрать себе по вкусу. Если вы затрудняетесь с выбором, просто откройте сайт поисковой системы и введите там одну из фраз:

\begin{itemize}
\itemкомпилятор C++ для Windows/Linux/OS X
\itemтекстовый редактор для программиста
\itemсреда разработки C++
\end{itemize}

Несколько минут поиска и вы найдете то, что нужно. А теперь перейдем непосредственно к языку.

Нормальные человеческие языки состоят из букв. Аналогично C++ состоит из символов. Значащими, т.е. теми, которые можно использовать в коде, являются 26 строчных и 26 заглавных английских букв, подчеркивание \_, все десятичные цифры, а также 29 специальных символов: 

\cppword{! {\char34}\#\%\&'()*+,-./:;<=>?[\textbackslash]\textasciicircum\{|\}\textasciitilde}

Остальные символы являются незначащими, например, кириллица или китайские иероглифы.

Программа на C++ представляет собой почти обыкновенный текст. Тексты на нормальных языках состоят из абзацев, предложений, слов и знаков препинания. Тексты на языках программирования аналогичным образом состоят из строк и лексем. Лексемы --- это единицы языка со смыслом, аналог слов в естественных языках --- служебные слова, идентификаторы, знаки операций, разделители и литералы. Они составляются из тех самых значащих символов.

\begin{lstlisting}[caption={Пример лексем}, captionpos=b, style=cpp]
int i = 0;
\end{lstlisting}

В примере выше \cppword{int} --- служебное слово, целый тип, \cppword{i} --- идентификатор, имя переменной, пробелы до и после знака равно --- разделители, сам знак \cppword{=} --- знак операции присваивания, \cppword{0} --- литерал (фиксированное значение), число ноль.

\fordummies{

Служебное слово --- слово, имеющее в языке программирования специальное значение. Например, const означает некоторое константное, неизменяемое выражение.

Идентификатор --- уникальный признак объекта, позволяющий отличать его от других объектов, или, попросту имя. С их помощью именуют переменные, функции, метки и т.п.

Знак операции --- аналог математических сокращений для операций. Например, i = 0 означает присвоить сущности под именем i значение 0.

Разделитель --- все, что отделяет одну лексему от другой --- пробелы, символы табулции, концы строк и комментарии.

Литерал --- фиксированное значение, например, число, строка, логическое значение истина (true) или ложь (false) и т.п.

}

\section*{Наша первая программа}

В программировании принято начинать обучение новому языку с написания простейшей программы, которая выводит на экран фразу <<Hello, world!>>. Так эта программа выглядит на C++:

\begin{lstlisting}[caption={Наша первая программа <<Hello, world!>>}, captionpos=b, style=cpp]
#include <iostream>
using namespace std;

int main() {
	cout << "Hello, World!" << endl;
	return 0;
}
\end{lstlisting}

Давайте разберемся, что построчно делает наша программа.

В первой строке подключается заголовочный файл \cppword{iostream} (input-output stream) для работы со стандартными средствами ввода-вывода. В C++ необходимо подключать заголовочные файлы библиотек для использования соответствующих элементов. Например, без \cppword{iostream} нельзя использовать ввод с клавиатуры и вывод на экран средствами C++, а без \cppword{cmath} не получится воспользоваться математическими функциями.

Второй строкой подключается пространство имен \cppword{std}. Пространство имен --- некоторая область, предназначенная для логической группировки идентификаторов. В большом проекте легко может случиться конфликт имен --- в программе присутствует огромное количество переменных и функций, за именами которых нужно следить. Например, существует стандартный объект вектор, который называется \cppword{vector}. Пользователь может создать свой объект с таким же названием, а компилятор не сможет определить, к какому объекту необходимо обращаться. Однако, все идентификаторы стандартной библиотеки C++ находятся в пространстве имен \cppword{std}, и полное наименование стандартного вектора будет \cppword{std::vector}. Теперь компилятору понятно, что \cppword{vector} --- пользовательский объект, а \cppword{std::vector} --- стандартный. В маленьких программах за именами следить легко, а много печатать не хочется, поэтому, чтобы вместо \cppword{std::vector} писать просто \cppword{vector}, подключается стандартное пространство имен. В нашей программе это подключение затрагивает имена \cppword{cout} и \cppword{endl} (см. пятую строку).

Третья строка содержит только символ перевода на новую строку. Это разделитель, который добавлен только для удобства, чтобы визуально отделить одну часть программы от другой. Более никакой смысловой нагрузки он не несет.

В четвертой строке определяется функция \cppword{main}. Функцию с таким именем должна содержать любая (строго говоря, есть и исключения) исполняемая программа на C++. Эта функция вызывается автоматически при запуске программы. \cppword{int} --- тип функции, означает, что она вернет результат в виде целого числа. В круглых скобках содержатся аргументы функции, но в данном случае их нет. В фигурных скобках содержится тело функции --- код, который выполняется каждый раз при вызове этой функции. Закрывающаяся скобка находится на строке 7.

Пятая строка делает то, ради чего все и затевалось, а именно печатает на экран сообщение <<Hello, World!>>. \cppword{cout} --- это поток вывода --- специальный объект, который печатает на экран то, что направляется в него операцией \cppword{<{}<}. \cppword{endl} --- стандартный идентификатор перехода на новую строку. \cppword{cout} и \cppword{endl} взяты из стандартной библиотеки. Для этого мы сначала подключили заголовок iostream, а потом, чтобы не писать \cppword{std::cout} и \cppword{std::endl} использовали пространство имен \cppword{std}. В двойных кавычках в C++ задаются строки.

Шестой строкой завершается функция \cppword{main}. \cppword{return 0} означает, что наша функция возвращает в качестве результата число ноль. Это результат будет передан операционной системе, когда программа завершится. Результат ноль означает успешное выполнение, а ненулевой сигнализирует об ошибке.

Точкой с запятой в C++ заканчивается операторы. См. строки 2, 5, 6.

Теперь можно смело набирать представленный код в выбранном вами редакторе или среде разработки. Программа должна скомпилироваться без ошибок. Если этого не случилось, проверьте, правильно ли вы переписали или скопировали пример. Посмотрите, не заменились ли какие-нибудь символы на другие, например, два уголка меньше <{}< на кавычки-елочки <<. Фраза Hello, World! должна заключаться в двойные кавычки. Проверьте, не забыли ли вы точки с запятой и не поставили ли лишних. Стоит посмотреть на сообщения компилятора, они достаточно точно идентифицируют проблемное место и иногда даже подсказывают решение. Если все успешно, то после компиляции и выполнения программы на экране должна появиться надпись:

Hello, World!

Поздравляю, вы успешно написали первую программу на C++.

\end{document}

